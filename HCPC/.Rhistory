setwd("~/GitHub/Dissertation/HCPC")
library(ProjectTemplate)
load.project()
library(Rcpp)
install.packages(c("bookdown", "broom", "cli", "haven", "isoband", "matrixStats", "pillar", "ProjectTemplate", "Rcpp", "RcppArmadillo", "readr", "reprex", "rmarkdown", "stringi", "tibble", "tinytex", "utf8", "xfun"))
install.packages(c("bookdown", "broom", "cli", "haven", "isoband", "matrixStats", "pillar", "ProjectTemplate", "Rcpp", "RcppArmadillo", "readr", "reprex", "rmarkdown", "stringi", "tibble", "tinytex", "utf8", "xfun"))
install.packages(c("bookdown", "broom", "cli", "haven", "isoband", "matrixStats", "pillar", "ProjectTemplate", "Rcpp", "RcppArmadillo", "readr", "reprex", "rmarkdown", "stringi", "tibble", "tinytex", "utf8", "xfun"))
install.packages(c("bookdown", "broom", "cli", "haven", "isoband", "matrixStats", "pillar", "ProjectTemplate", "Rcpp", "RcppArmadillo", "readr", "reprex", "rmarkdown", "stringi", "tibble", "tinytex", "utf8", "xfun"))
install.packages(c("bookdown", "broom", "cli", "haven", "isoband", "matrixStats", "pillar", "ProjectTemplate", "Rcpp", "RcppArmadillo", "readr", "reprex", "rmarkdown", "stringi", "tibble", "tinytex", "utf8", "xfun"))
install.packages(c("bookdown", "broom", "cli", "haven", "isoband", "matrixStats", "pillar", "ProjectTemplate", "Rcpp", "RcppArmadillo", "readr", "reprex", "rmarkdown", "stringi", "tibble", "tinytex", "utf8", "xfun"))
install.packages(c("bookdown", "broom", "cli", "haven", "isoband", "matrixStats", "pillar", "ProjectTemplate", "Rcpp", "RcppArmadillo", "readr", "reprex", "rmarkdown", "stringi", "tibble", "tinytex", "utf8", "xfun"))
install.packages(c("bookdown", "broom", "cli", "haven", "isoband", "matrixStats", "pillar", "ProjectTemplate", "Rcpp", "RcppArmadillo", "readr", "reprex", "rmarkdown", "stringi", "tibble", "tinytex", "utf8", "xfun"))
install.packages("spmod")
library(Rcpp)
library(raster)
library(quadmesh)
r <- raster(volcano)
## make the qm in three forms
qm2 <- qm3 <- qm1 <- quadmesh(r)
## update the colours based on the data, then update the vertices
scl <- function(x) (x - min(x, na.rm = TRUE))/diff(range(x, na.rm = TRUE))
qm1$material$col <- viridis::inferno(26)[scl(qm1$vb[3, qm1$ib]) * 25 + 1]
qm1$vb[3, ] <- 1
qm2$material$col <- viridis::viridis(26)[scl(qm2$vb[3, qm2$ib]) * 25 + 1]
qm2$vb[3, ] <- 2
qm3$material$col <- rev(viridis::magma(26))[scl(qm3$vb[3, qm3$ib]) * 25 + 1]
qm3$vb[3, ] <- 3
## adding to a plot is the default
shade3d(qm1)
shade3d(qm2)
shade3d(qm3)
aspect3d(1, 1, 1)
install.packages("UScensus2000tract")
# load data
data("oregon.tract")
library(UScensus2000tract)
# load data
data("oregon.tract")
# plot Census Tract map
plot(oregon.tract)
# create a unique character ID value:
oregon.tract$id=as.character(1:nrow(oregon.tract))
# Fortify on that ID and join attribute data:
ofort <- fortify(oregon.tract,region="id")
library(ggplot2)
# Fortify on that ID and join attribute data:
ofort <- fortify(oregon.tract,region="id")
ofort <- left_join(ofort, oregon.tract@data, c("id"="id"))
library(ProjectTemplate)
load.project()
ofort <- left_join(ofort, oregon.tract@data, c("id"="id"))
# Shear/scale matrix [[2,1],[0,1]] obtained by some trial and error:
sm <- matrix(c(2,1.2,0,1),2,2)
# Get transformed coordinates:
xy <- as.matrix(ofort[,c("long","lat")]) %*% sm
# Add xy as extra columns in fortified data:
ofort$x <- xy[,1]; ofort$y = xy[,2]
# Plot !
ggplot(ofort, aes(x=x, y=y, group=id, fill=white)) + geom_polygon() + coord_fixed()
ggplot(data= ofort) +
geom_polygon( aes(x=x, y=y, group=id), fill= "white", color="gray30") + # layer 1
geom_polygon( aes(x=x, y=y+5, group=id, fill=white)) +                  # layer 2
geom_polygon( aes(x=x, y=y+10, group=id, fill=pop2000-white)) +         # layer 3
theme(axis.text=element_blank(), axis.ticks=element_blank()) +
scale_fill_distiller(palette = "RdBu", name = "Population") +
annotate("text", x = -197, y = 45, size=5, color="gray35", label = "Census tracts") + # layer 1
annotate("text", x = -197, y = 50, size=5, color="gray35", label = "White") +         # layer 2
annotate("text", x = -197, y = 55, size=5, color="gray35", label = "Non-white") +     # layer 3
coord_fixed()
r= raster("C:/Users/jelli/Desktop/Terra Environmental Variables/Low_res/aermr02_kgkg_4326_01_cropped_rescaled.tif")
install.packages("rgdal")
library(rgdal)
r= raster("C:/Users/jelli/Desktop/Terra Environmental Variables/Low_res/aermr02_kgkg_4326_01_cropped_rescaled.tif")
# plot Census Tract map
plot(r)
# create a unique character ID value:
r.tract$id=as.character(1:nrow(oregon.tract))
# create a unique character ID value:
r$id=as.character(1:nrow(oregon.tract))
r
r= aggregate(r, fact=3)
r
plot(r)
# create a unique character ID value:
r$id=as.character(1:nrow(r))
r= aggregate(r, fact=3)
r
# create a unique character ID value:
r$id=as.character(1:nrow(r))
r= aggregate(r, fact=10)
r
plot(t)
plot(r)
r= raster("C:/Users/jelli/Desktop/Terra Environmental Variables/Low_res/aermr02_kgkg_4326_01_cropped_rescaled.tif")
r= aggregate(r, fact=10)
r
plot(r)
# create a unique character ID value:
r$id=as.character(1:nrow(r))
r= aggregate(r, fact=3)
plot(r)
# create a unique character ID value:
r$id=as.character(1:nrow(r))
r
install.packages("anglr")
## make the qm in three forms
qm2 <- qm3 <- qm1 <- quadmesh(r)
## update the colours based on the data, then update the vertices
scl <- function(x) (x - min(x, na.rm = TRUE))/diff(range(x, na.rm = TRUE))
qm1$material$col <- viridis::inferno(26)[scl(qm1$vb[3, qm1$ib]) * 25 + 1]
qm1$vb[3, ] <- 1
qm2$material$col <- viridis::viridis(26)[scl(qm2$vb[3, qm2$ib]) * 25 + 1]
qm2$vb[3, ] <- 2
qm3$material$col <- rev(viridis::magma(26))[scl(qm3$vb[3, qm3$ib]) * 25 + 1]
qm3$vb[3, ] <- 3
## adding to a plot is the default
shade3d(qm1)
shade3d(qm2)
shade3d(qm3)
aspect3d(1, 1, 1)
r= raster("C:/Users/jelli/Desktop/Terra Environmental Variables/Low_res/aermr02_kgkg_4326_01_cropped_rescaled.tif")
## make the qm in three forms
qm2 <- qm3 <- qm1 <- quadmesh(r)
## update the colours based on the data, then update the vertices
scl <- function(x) (x - min(x, na.rm = TRUE))/diff(range(x, na.rm = TRUE))
qm1$material$col <- viridis::inferno(26)[scl(qm1$vb[3, qm1$ib]) * 25 + 1]
qm1$vb[3, ] <- 1
qm2$material$col <- viridis::viridis(26)[scl(qm2$vb[3, qm2$ib]) * 25 + 1]
qm2$vb[3, ] <- 2
qm3$material$col <- rev(viridis::magma(26))[scl(qm3$vb[3, qm3$ib]) * 25 + 1]
qm3$vb[3, ] <- 3
## adding to a plot is the default
shade3d(qm1)
shade3d(qm2)
shade3d(qm3)
aspect3d(1, 1, 1)
remotes::install_github("brentthorne/posterdown")
install.packages("remotes")
remotes::install_github("brentthorne/posterdown")
#only show 2 d.p.
options(digits=2)
#ffp location data
ffp_df= read.csv("./data/ffp_variable_means.csv")
rownames(ffp_df)= ffp_df$city
ffp_df= apply(ffp_df[2:7],2, function(x)(x/mean(x)*100))
columns= c("TOW", "UV Radiation", "Temperature", "Total Precipitation", "Electrolyte Concentration", "FOW")
colnames(ffp_df)= columns
#lowest similarities cities data
lowest_df= read.csv("./data/lowest_sim_variable_means.csv")
rownames(lowest_df)= lowest_df$city
lowest_df=apply(lowest_df[2:7],2, function(x) (x/mean(x)*100))
columns= c("TOW", "UV Radiation", "Temperature", "Total Precipitation", "Electrolyte Concentration", "FOW")
colnames(lowest_df)= columns
install.packages("fsmb")
library(fsmb)
install.packages(c("cli", "httpuv", "later", "readr", "websocket"))
install.packages("fsmb")
